<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Travel Tracker Globe</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #0a0a0a;
            color: white;
            overflow: hidden;
        }
        #header {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            text-align: center;
            z-index: 10;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 2rem;
        }
        p {
            margin: 0;
            color: #999;
            font-size: 0.9rem;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            z-index: 5;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>üåç Travel Tracker Globe</h1>
        <p>Drag to rotate ‚Ä¢ All countries shown in grey</p>
    </div>
    <div id="loading">Loading globe...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        console.log('Three.js loaded:', typeof THREE);

        const loading = document.getElementById('loading');

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        // Camera
        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.z = 300;

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create globe
        const globeGeometry = new THREE.SphereGeometry(100, 64, 64);
        const globeMaterial = new THREE.MeshPhongMaterial({
            color: 0x2a2a3e,
            emissive: 0x1a1a2e,
            shininess: 5
        });
        const globe = new THREE.Mesh(globeGeometry, globeMaterial);
        scene.add(globe);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(200, 100, 200);
        scene.add(directionalLight);

        // Load country borders
        fetch('https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_110m_admin_0_countries.geojson')
            .then(res => res.json())
            .then(data => {
                console.log('Countries loaded:', data.features.length);

                data.features.forEach(feature => {
                    const coords = feature.geometry.coordinates;
                    const type = feature.geometry.type;

                    const latLonToVector3 = (lon, lat, radius) => {
                        const phi = (90 - lat) * (Math.PI / 180);
                        const theta = (lon + 180) * (Math.PI / 180);
                        const x = -radius * Math.sin(phi) * Math.cos(theta);
                        const y = radius * Math.cos(phi);
                        const z = radius * Math.sin(phi) * Math.sin(theta);
                        return new THREE.Vector3(x, y, z);
                    };

                    const drawPolygon = (polygonCoords) => {
                        polygonCoords.forEach(ring => {
                            const points = ring.map(([lon, lat]) => 
                                latLonToVector3(lon, lat, 100.5)
                            );

                            if (points.length > 1) {
                                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                                const material = new THREE.LineBasicMaterial({
                                    color: 0xaaaaaa,
                                    linewidth: 1
                                });
                                const line = new THREE.Line(geometry, material);
                                globe.add(line);
                            }
                        });
                    };

                    if (type === 'Polygon') {
                        drawPolygon(coords);
                    } else if (type === 'MultiPolygon') {
                        coords.forEach(polygon => drawPolygon(polygon));
                    }
                });

                loading.style.display = 'none';
                console.log('Borders rendered');
            })
            .catch(err => {
                console.error('Error:', err);
                loading.textContent = 'Error loading countries';
            });

        // Mouse interaction
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            globe.rotation.y += deltaX * 0.005;
            globe.rotation.x += deltaY * 0.005;

            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Touch support
        renderer.domElement.addEventListener('touchstart', (e) => {
            isDragging = true;
            previousMousePosition = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
            };
        });

        renderer.domElement.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            e.preventDefault();

            const deltaX = e.touches[0].clientX - previousMousePosition.x;
            const deltaY = e.touches[0].clientY - previousMousePosition.y;

            globe.rotation.y += deltaX * 0.005;
            globe.rotation.x += deltaY * 0.005;

            previousMousePosition = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
            };
        });

        renderer.domElement.addEventListener('touchend', () => {
            isDragging = false;
        });

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Gentle auto-rotation when not dragging
            if (!isDragging) {
                globe.rotation.y += 0.001;
            }

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
